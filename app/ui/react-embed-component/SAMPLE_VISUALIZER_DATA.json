{
  "code": "import React, { useState, useEffect, useRef } from 'react';\n\ninterface Node {\n  id: string;\n  x: number;\n  y: number;\n}\n\ninterface Edge {\n  from: string;\n  to: string;\n  weight: number;\n}\n\nconst InteractiveDijkstraVisualizer: React.FC = () => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [nodes, setNodes] = useState<Node[]>([\n    { id: 'A', x: 50, y: 100 },\n    { id: 'B', x: 200, y: 50 },\n    { id: 'C', x: 200, y: 150 },\n    { id: 'D', x: 350, y: 100 },\n  ]);\n  const [edges, setEdges] = useState<Edge[]>([\n    { from: 'A', to: 'B', weight: 4 },\n    { from: 'A', to: 'C', weight: 2 },\n    { from: 'B', to: 'D', weight: 5 },\n    { from: 'C', to: 'D', weight: 1 },\n    { from: 'B', to: 'C', weight: 1 },\n  ]);\n  const [startNode, setStartNode] = useState<string>('A');\n  const [distances, setDistances] = useState<{ [key: string]: number }>({});\n  const [path, setPath] = useState<{ [key: string]: string | null }>({});\n  const [selectedNode, setSelectedNode] = useState<string | null>(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragOffset, setDragOffset] = useState<{ x: number; y: number } | null>(null);\n  const [newEdgeStartNode, setNewEdgeStartNode] = useState<string | null>(null);\n  const [newEdgeEndNode, setNewEdgeEndNode] = useState<string | null>(null);\n  const [newEdgeWeight, setNewEdgeWeight] = useState<number | ''>('');\n\n  useEffect(() => {\n    drawGraph();\n    runDijkstra();\n  }, [nodes, edges, startNode]);\n\n  const drawGraph = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // Draw edges\n    edges.forEach((edge) => {\n      const fromNode = nodes.find((n) => n.id === edge.from);\n      const toNode = nodes.find((n) => n.id === edge.to);\n      if (fromNode && toNode) {\n        ctx.beginPath();\n        ctx.moveTo(fromNode.x, fromNode.y);\n        ctx.lineTo(toNode.x, toNode.y);\n        ctx.strokeStyle = '#333';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n        // Draw weight\n        const midX = (fromNode.x + toNode.x) / 2;\n        const midY = (fromNode.y + toNode.y) / 2;\n        ctx.fillStyle = '#555';\n        ctx.font = '12px sans-serif';\n        ctx.textAlign = 'center';\n        ctx.fillText(String(edge.weight), midX, midY - 5);\n      }\n    });\n\n    // Draw nodes\n    nodes.forEach((node) => {\n      ctx.beginPath();\n      ctx.arc(node.x, node.y, 15, 0, 2 * Math.PI);\n      ctx.fillStyle = node.id === startNode ? 'lightblue' : selectedNode === node.id ? 'yellow' : '#eee';\n      ctx.strokeStyle = '#333';\n      ctx.lineWidth = 2;\n      ctx.fill();\n      ctx.stroke();\n      // Draw node id\n      ctx.fillStyle = '#000';\n      ctx.font = '14px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(node.id, node.x, node.y + 5);\n    });\n\n    // Highlight shortest paths\n    for (const targetNodeId in path) {\n      let current = targetNodeId;\n      while (path[current]) {\n        const prev = path[current]!;\n        const fromNode = nodes.find((n) => n.id === prev);\n        const toNode = nodes.find((n) => n.id === current);\n        if (fromNode && toNode) {\n          ctx.beginPath();\n          ctx.moveTo(fromNode.x, fromNode.y);\n          ctx.lineTo(toNode.x, toNode.y);\n          ctx.strokeStyle = 'green';\n          ctx.lineWidth = 4;\n          ctx.stroke();\n        }\n        current = prev;\n      }\n    }\n\n    // Drawing new edge in progress\n    if (newEdgeStartNode) {\n      const start = nodes.find(n => n.id === newEdgeStartNode);\n      const endX = newEdgeEndNode ? nodes.find(n => n.id === newEdgeEndNode)?.x : mousePosition.current.x;\n      const endY = newEdgeEndNode ? nodes.find(n => n.id === newEdgeEndNode)?.y : mousePosition.current.y;\n      if (start) {\n        ctx.beginPath();\n        ctx.moveTo(start.x, start.y);\n        ctx.lineTo(endX, endY);\n        ctx.strokeStyle = 'orange';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n      }\n    }\n  };\n\n  const runDijkstra = () => {\n    const unvisited = new Set(nodes.map((node) => node.id));\n    const currentDistances: { [key: string]: number } = {};\n    const currentPath: { [key: string]: string | null } = {};\n\n    nodes.forEach((node) => {\n      currentDistances[node.id] = Infinity;\n      currentPath[node.id] = null;\n    });\n\n    currentDistances[startNode] = 0;\n\n    while (unvisited.size > 0) {\n      let minDistance = Infinity;\n      let currentNodeId: string | null = null;\n\n      unvisited.forEach((nodeId) => {\n        if (currentDistances[nodeId] < minDistance) {\n          minDistance = currentDistances[nodeId];\n          currentNodeId = nodeId;\n        }\n      });\n\n      if (currentNodeId === null) {\n        break;\n      }\n\n      unvisited.delete(currentNodeId);\n\n      const neighbors = edges\n        .filter((edge) => edge.from === currentNodeId)\n        .map((edge) => ({ to: edge.to, weight: edge.weight }))\n        .concat(edges\n          .filter((edge) => edge.to === currentNodeId)\n          .map((edge) => ({ to: edge.from, weight: edge.weight }))); // Assuming undirected edges\n\n      neighbors.forEach((neighbor) => {\n        const distance = currentDistances[currentNodeId!] + neighbor.weight;\n        if (distance < currentDistances[neighbor.to]) {\n          currentDistances[neighbor.to] = distance;\n          currentPath[neighbor.to] = currentNodeId;\n        }\n      });\n    }\n\n    setDistances(currentDistances);\n    setPath(currentPath);\n  };\n\n  const handleStartNodeChange = (event: React.ChangeEvent<HTMLSelectElement>) => {\n    setStartNode(event.target.value);\n  };\n\n  const handleCanvasMouseDown = (event: React.MouseEvent<HTMLCanvasElement>) => {\n    const canvasX = event.clientX - canvasRef.current!.getBoundingClientRect().left;\n    const canvasY = event.clientY - canvasRef.current!.getBoundingClientRect().top;\n\n    nodes.forEach((node) => {\n      const distance = Math.sqrt((canvasX - node.x) ** 2 + (canvasY - node.y) ** 2);\n      if (distance < 15) {\n        setSelectedNode(node.id);\n        setIsDragging(true);\n        setDragOffset({ x: canvasX - node.x, y: canvasY - node.y });\n      }\n    });\n  };\n\n  const handleCanvasMouseMove = (event: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!isDragging || !selectedNode || !dragOffset) return;\n    const canvasX = event.clientX - canvasRef.current!.getBoundingClientRect().left;\n    const canvasY = event.clientY - canvasRef.current!.getBoundingClientRect().top;\n\n    setNodes((prevNodes) =>\n      prevNodes.map((node) =>\n        node.id === selectedNode ? { ...node, x: canvasX - dragOffset.x, y: canvasY - dragOffset.y } : node\n      )\n    );\n  };\n\n  const handleCanvasMouseUp = () => {\n    setIsDragging(false);\n    setSelectedNode(null);\n  };\n\n  const handleAddNode = () => {\n    const newNodeId = String.fromCharCode(65 + nodes.length);\n    setNodes([...nodes, { id: newNodeId, x: Math.random() * 350 + 25, y: Math.random() * 150 + 25 }]);\n  };\n\n  const handleStartAddEdge = (nodeId: string) => {\n    setNewEdgeStartNode(nodeId);\n  };\n\n  const handleEndAddEdge = (nodeId: string) => {\n    if (newEdgeStartNode && newEdgeStartNode !== nodeId) {\n      setNewEdgeEndNode(nodeId);\n    }\n  };\n\n  const handleNewEdgeWeightChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setNewEdgeWeight(Number(event.target.value));\n  };\n\n  const handleConfirmNewEdge = () => {\n    if (newEdgeStartNode && newEdgeEndNode && typeof newEdgeWeight === 'number') {\n      setEdges([...edges, { from: newEdgeStartNode, to: newEdgeEndNode, weight: newEdgeWeight }]);\n      setNewEdgeStartNode(null);\n      setNewEdgeEndNode(null);\n      setNewEdgeWeight('');\n    }\n  };\n\n  const mousePosition = useRef({ x: 0, y: 0 });\n  const handleCanvasMouseLeave = () => {\n    if (newEdgeStartNode && !newEdgeEndNode) {\n      setNewEdgeStartNode(null);\n    }\n  };\n\n  const handleCanvasMoveForEdge = (event: React.MouseEvent<HTMLCanvasElement>) => {\n    mousePosition.current = {\n      x: event.clientX - canvasRef.current!.getBoundingClientRect().left,\n      y: event.clientY - canvasRef.current!.getBoundingClientRect().top,\n    };\n    drawGraph(); // Redraw to show the edge being dragged\n  };\n\n  return (\n    <div style={styles.container}>\n      <h2 style={styles.heading}>Interactive Dijkstra's Algorithm</h2>\n\n      <div style={styles.controls}>\n        <label htmlFor=\"startNode\">Start Node:</label>\n        <select id=\"startNode\" value={startNode} onChange={handleStartNodeChange}>\n          {nodes.map((node) => (\n            <option key={node.id} value={node.id}>{node.id}</option>\n          ))}\n        </select>\n        <button onClick={handleAddNode}>Add Node</button>\n        {newEdgeStartNode && !newEdgeEndNode && <span>Drawing edge from {newEdgeStartNode}</span>}\n        {newEdgeStartNode && newEdgeEndNode && (\n          <span>\n            Weight: <input type=\"number\" value={newEdgeWeight} onChange={handleNewEdgeWeightChange} style={{ width: '50px' }} />\n            <button onClick={handleConfirmNewEdge}>Confirm Edge</button>\n          </span>\n        )}\n      </div>\n\n      <canvas\n        ref={canvasRef}\n        width={400}\n        height={200}\n        style={styles.canvas}\n        onMouseDown={handleCanvasMouseDown}\n        onMouseMove={isDragging ? handleCanvasMouseMove : newEdgeStartNode && !newEdgeEndNode ? handleCanvasMoveForEdge : () => {}}\n        onMouseUp={handleCanvasMouseUp}\n        onMouseLeave={handleCanvasMouseLeave}\n        onClick={(event) => {\n          const canvasX = event.clientX - canvasRef.current!.getBoundingClientRect().left;\n          const canvasY = event.clientY - canvasRef.current!.getBoundingClientRect().top;\n          nodes.forEach(node => {\n            const distance = Math.sqrt((canvasX - node.x) ** 2 + (canvasY - node.y) ** 2);\n            if (distance < 15) {\n              if (newEdgeStartNode && newEdgeStartNode !== node.id && !newEdgeEndNode) {\n                handleEndAddEdge(node.id);\n              } else if (!newEdgeStartNode) {\n                handleStartAddEdge(node.id);\n              }\n            }\n          });\n        }}\n      />\n\n      <div style={styles.distances}>\n        <h3>Shortest Distances from Node {startNode}:</h3>\n        <ul>\n          {Object.entries(distances).map(([nodeId, dist]) => (\n            <li key={nodeId}>\n              {nodeId}: {dist === Infinity ? 'Infinity' : dist}\n            </li>\n          ))}\n        </ul>\n      </div>\n    </div>\n  );\n};\n\nconst styles = {\n  container: {\n    fontFamily: 'sans-serif',\n    textAlign: 'center',\n  },\n  heading: {\n    color: '#333',\n    marginBottom: '20px',\n  },\n  controls: {\n    marginBottom: '20px',\n  },\n  canvas: {\n    border: '1px solid #ccc',\n    marginBottom: '20px',\n    cursor: 'grab',\n  },\n  distances: {\n    textAlign: 'left',\n    margin: '20px auto',\n    maxWidth: '300px',\n  },\n};\n\nexport default InteractiveDijkstraVisualizer;\n"
}